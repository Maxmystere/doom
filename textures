srcs/manager/arch_manager.c:8:	while (i < arch->sdl->size.x)
srcs/manager/arch_manager.c:10:		arch->bound.b_up[i] = 0;
srcs/manager/arch_manager.c:11:		arch->bound.b_down[i] = arch->sdl->size.y;
srcs/manager/arch_manager.c:14:	arch->bound.b_left = arch->cam->fov / 2.0;
srcs/manager/arch_manager.c:15:	arch->bound.b_right = -arch->cam->fov / 2.0;
srcs/manager/arch_manager.c:23:	while (i < arch->sdl->size.x)
srcs/manager/arch_manager.c:25:		arch->bound.zline[i] = 0;
srcs/manager/arch_manager.c:38:	free(arch->bound.zline);
srcs/manager/arch_manager.c:46:	arch->bound.zline = (double*)malloc(sizeof(double) * sdl->size.x);
srcs/manager/arch_manager.c:47:	if (!arch->bound.zline)
srcs/manager/arch_manager.c:50:	arch->sdl = sdl;
srcs/manager/arch_manager.c:51:	arch->cam = cam;
srcs/manager/arch_manager.c:52:	arch->bound.b_down = (uint32_t*)malloc(sizeof(uint32_t) * sdl->size.x);
srcs/manager/arch_manager.c:53:	if (!arch->bound.b_down)
srcs/manager/arch_manager.c:55:	arch->bound.b_up = (uint32_t*)malloc(sizeof(uint32_t) * sdl->size.x);
srcs/manager/arch_manager.c:56:	if (!arch->bound.b_up)
srcs/manager/arch_manager.c:58:	arch->wall = NULL;
srcs/manager/borne_manager.c:11:	while (i < arch->sdl->size.x)
srcs/manager/borne_manager.c:13:		arch->bound.b_up[i] = 0;
srcs/manager/borne_manager.c:14:		arch->bound.b_down[i] = arch->sdl->size.y;
srcs/manager/borne_manager.c:15:		arch->bound.zline[i] = 0;
srcs/manager/borne_manager.c:18:	arch->bound.b_left = arch->cam->fov / 2.0;
srcs/manager/borne_manager.c:19:	arch->bound.b_right = -arch->cam->fov / 2.0;
srcs/parsing/chunk_ressources.c:43:	arch->texture = (SDL_Surface**)malloc(sizeof(SDL_Surface*) * (size + 1));
srcs/parsing/chunk_ressources.c:44:	if (!arch->texture)
srcs/parsing/chunk_ressources.c:46:	arch->texture[size] = NULL;
srcs/parsing/chunk_ressources.c:53:		arch->texture[i] = SDL_ConvertSurface((SDL_Surface*)tmp, sdl->format, 0);
srcs/parsing/chunk_ressources.c:54:		if (!arch->texture[i])
srcs/render/backface.c:14:	if (len_pillar > arch->bound.zline[px])
srcs/render/backface.c:16:		arch->bound.zline[px] = len_pillar;
srcs/render/backface.c:25:	if (len_pillar > arch->bound.zline[px])
srcs/render/backface.c:27:		arch->bound.zline[px] = 0;
srcs/render/backface.c:41:	if (len_pillar > arch->bound.zline[arch->px.x])
srcs/render/backface.c:43:		zline_tmp[arch->px.x - start] = len_pillar;
srcs/render/backface.c:44:		arch->bound.zline[arch->px.x] = 0;
srcs/render/backface.c:47:	zline_tmp[arch->px.x - start] = arch->bound.zline[arch->px.x];
srcs/render/backface.c:62:	while (start < arch->px.y)
srcs/render/backface.c:64:		arch->bound.zline[start] = zline_cut[i];
srcs/render/borne.c:14:	arch->bound.b_up[i] = (uint32_t)trunc_int(surface.x, 0, arch->bound.b_up[arch->px.x] - 1);
srcs/render/borne.c:15:	arch->bound.b_down[i] = (uint32_t)trunc_int(surface.y, 0, arch->bound.b_down[arch->px.x] - 1);
srcs/render/borne.c:20:	arch->bound.b_left = atan2((arch->sdl->size.x / 2) - arch->px.x, arch->cam->d_screen);
srcs/render/borne.c:21:	arch->bound.b_right = atan2((arch->sdl->size.x / 2) - arch->px.y, arch->cam->d_screen);
srcs/render/borne.c:22:	arch->bound.b_left *= TOANGLE;
srcs/render/borne.c:23:	arch->bound.b_right *= TOANGLE;
srcs/render/borne.c:34:	len = arch->px.y - arch->px.x;
srcs/render/borne.c:35:	borne->b_left = arch->bound.b_left;
srcs/render/borne.c:36:	borne->b_right = arch->bound.b_right;
srcs/render/borne.c:68:	arch->bound.b_left = borne->b_left;
srcs/render/borne.c:69:	arch->bound.b_right = borne->b_right;
srcs/render/borne.c:70:	while (start < arch->px.y)
srcs/render/borne.c:72:		arch->bound.b_up[start] = borne->b_up[i];
srcs/render/borne.c:73:		arch->bound.b_down[start] = borne->b_down[i];
srcs/render/borne.c:74:		arch->bound.zline[start] = borne->zline[i];
srcs/render/bunch.c:23:	if (angle >= arch->bound.b_right && angle <= arch->bound.b_left)
srcs/render/bunch.c:51:	if (arch->bound.b_left * arch->bound.b_right > 0)
srcs/render/bunch.c:87:	angles.x = local_angle(arch->bound.b_left, wall->pillar->angle);
srcs/render/bunch.c:88:	angles.y = local_angle(arch->bound.b_left, wall->next->angle);
srcs/render/bunch.c:133:			&& equal_pillar(&wall[i_wall], arch->wall))
srcs/render/bunch.c:140:			&& equal_pillar(&wall[i_wall], arch->wall))
srcs/render/bunch.c:156:	arch->sector = sector;
srcs/render/bunch.c:159:		arch->wall = bunch[i];
srcs/render/draw_column.c:16:	coef = (double)arch->wall->txtr.h / (surface.y - surface.x);
srcs/render/draw_column.c:17:	if (surface.y < (int)arch->bound.b_up[arch->px.x])
srcs/render/draw_column.c:18:		return (numcol + surface.y * arch->sdl->size.x);
srcs/render/draw_column.c:19:	if (surface.x < (int)arch->bound.b_up[arch->px.x])
srcs/render/draw_column.c:21:		buff = (-surface.x + arch->bound.b_up[arch->px.x]) * coef;
srcs/render/draw_column.c:24:			px += (int)buff * arch->wall->txtr.w;
srcs/render/draw_column.c:27:		surface.x = arch->bound.b_up[arch->px.x];
srcs/render/draw_column.c:29:	while (surface.x < surface.y && surface.x < (int)arch->bound.b_down[arch->px.x])
srcs/render/draw_column.c:31:		arch->sdl->screen[numcol] = arch->wall->txtr.pixels[px];
srcs/render/draw_column.c:33:		numcol += arch->sdl->size.x;
srcs/render/draw_column.c:37:			px += (int)buff * arch->wall->txtr.w;
srcs/render/draw_column.c:52:	if (surface.x <= (int)arch->bound.b_up[arch->px.x])
srcs/render/draw_column.c:53:		surface.x = arch->px.x + arch->bound.b_up[arch->px.x] * arch->sdl->size.x;
srcs/render/draw_column.c:55:		surface.x = surface.x * arch->sdl->size.x + arch->px.x;
srcs/render/draw_column.c:56:	if (surface.y > (int)arch->bound.b_down[arch->px.x])
srcs/render/draw_column.c:57:		surface.y = arch->px.x + (arch->bound.b_down[arch->px.x] - 1) * arch->sdl->size.x;
srcs/render/draw_column.c:59:		surface.y = surface.y * arch->sdl->size.x;
srcs/render/draw_column.c:63:		arch->sdl->screen[surface.x] = color;
srcs/render/draw_column.c:64:		surface.x += arch->sdl->size.x;
srcs/render/draw_column.c:74:	surface_tmp = (t_vct2){arch->bound.b_up[arch->px.x], surface.x};
srcs/render/draw_column.c:78:	surface_tmp = (t_vct2){surface.y, arch->bound.b_down[arch->px.x]};
srcs/render/draw_column.c:87:**	-->renvoie sans le facteur largeur (arch->sdl->size.x)
srcs/render/draw_column.c:117:	s_portal = surface_portal(surface, arch->sector, arch->wall->link);
srcs/render/draw_column.c:119:	tmp = (t_vct2){arch->bound.b_up[arch->px.x], surface.x};
srcs/render/draw_column.c:124:	//set_borne_vertical(arch, tmp, arch->px.x);
srcs/render/draw_column.c:128:	tmp = (t_vct2){surface.y, arch->bound.b_down[arch->px.x]};
srcs/render/draw_column.c:130:	parent_borne->b_up[arch->px.x - start] = arch->bound.b_up[arch->px.x];
srcs/render/draw_column.c:131:	parent_borne->b_down[arch->px.x - start] = arch->bound.b_down[arch->px.x];
srcs/render/draw_column.c:134:	set_borne_vertical(arch, tmp, arch->px.x);
srcs/render/pillar_info.c:15:	angle.x = local_angle(arch->bound.b_left, arch->wall->pillar->angle);
srcs/render/pillar_info.c:16:	angle.y = local_angle(arch->bound.b_left, arch->wall->next->angle);
srcs/render/pillar_info.c:19:	polarite = (arch->wall->next->angle > arch->bound.b_left ? -1 : 1) * (diff < 180 ? 1 : -1);
srcs/render/pillar_info.c:20:	arch->px.x = (polarite == -1) ? 0 : arch->sdl->size.x -1;
srcs/render/pillar_info.c:21:	arch->px.y = arch->sdl->size.x - 1 - arch->px.x;
srcs/render/pillar_info.c:30:	angle = local_angle(arch->bound.b_left, pillar->angle);
srcs/render/pillar_info.c:31:	angle_next = local_angle(arch->bound.b_left, next->angle);
srcs/render/pillar_info.c:32:	borne = local_angle(arch->bound.b_left, arch->bound.b_right);
srcs/render/pillar_info.c:38:		return (arch->sdl->size.x - 1);
srcs/render/pillar_info.c:42:		return (arch->sdl->size.x - 1);
srcs/render/pillar_info.c:52:	size = arch->sdl->size.x;
srcs/render/pillar_info.c:53:	if (arch->wall->pillar->frust)
srcs/render/pillar_info.c:55:		arch->px.x = fish_bowl_px(arch, *arch->wall->pillar);
srcs/render/pillar_info.c:56:		arch->depth.x = distance(*(t_fvct2*)&p->stat.pos, arch->wall->pillar->p);
srcs/render/pillar_info.c:57:		arch->decal.x = sin(arch->wall->pillar->angle * PI180) * arch->depth.x;
srcs/render/pillar_info.c:58:		arch->depth.x = cos(arch->wall->pillar->angle * PI180) * arch->depth.x;
srcs/render/pillar_info.c:59:		arch->shift_txtr.x = 1;
srcs/render/pillar_info.c:63:		arch->px.x = pillar_polarite(arch, arch->wall->pillar, arch->wall->next);
srcs/render/pillar_info.c:64:		if (arch->px.x == 0)
srcs/render/pillar_info.c:66:			arch->px.x = arch->sdl->size.x / 2.0 - (tan(arch->bound.b_left * PI180) * arch->cam->d_screen);
srcs/render/pillar_info.c:67:			angle = p->stat.rot.y + arch->bound.b_left;
srcs/render/pillar_info.c:71:			arch->px.x = arch->sdl->size.x / 2.0 - (tan(arch->bound.b_right * PI180) * arch->cam->d_screen);
srcs/render/pillar_info.c:72:			angle = p->stat.rot.y + arch->bound.b_right;
srcs/render/pillar_info.c:74:		arch->shift_txtr.x = wall_clipping(arch, p, &tmp, angle);
srcs/render/pillar_info.c:75:		arch->depth.x = tmp.x;
srcs/render/pillar_info.c:76:		arch->decal.x = tmp.y;
srcs/render/pillar_info.c:78:	if (arch->wall->next->frust)
srcs/render/pillar_info.c:80:		arch->px.y = fish_bowl_px(arch, *arch->wall->next);
srcs/render/pillar_info.c:81:		arch->depth.y = distance(*(t_fvct2*)&p->stat.pos, arch->wall->next->p);
srcs/render/pillar_info.c:82:		arch->decal.y = sin(arch->wall->next->angle * PI180) * arch->depth.y;
srcs/render/pillar_info.c:83:		arch->depth.y = cos(arch->wall->next->angle * PI180) * arch->depth.y;
srcs/render/pillar_info.c:84:		arch->shift_txtr.y = 0;
srcs/render/pillar_info.c:88:		arch->px.y = pillar_polarite(arch, arch->wall->next, arch->wall->pillar);
srcs/render/pillar_info.c:89:		if (arch->px.y == 0)
srcs/render/pillar_info.c:91:			arch->px.y = arch->sdl->size.x / 2.0 - (tan(arch->bound.b_left * PI180) * arch->cam->d_screen);
srcs/render/pillar_info.c:92:			angle = p->stat.rot.y + arch->bound.b_left;
srcs/render/pillar_info.c:96:			arch->px.y = arch->sdl->size.x / 2.0 - (tan(arch->bound.b_right * PI180) * arch->cam->d_screen);
srcs/render/pillar_info.c:97:			angle = p->stat.rot.y + arch->bound.b_right;
srcs/render/pillar_info.c:99:		arch->shift_txtr.y = wall_clipping(arch, p, &tmp, angle);
srcs/render/pillar_info.c:100:		arch->depth.y = tmp.x;
srcs/render/pillar_info.c:101:		arch->decal.y = tmp.y;
srcs/render/pillar_info.c:109:	if (arch->bound.a_portal.a != -2)
srcs/render/render_effect.c:9:	sx = arch->sdl->size.x / 2.0;
srcs/render/render_effect.c:10:	px = sx - (tan(pillar.angle * PI180) * arch->cam->d_screen);
srcs/render/render_wall.c:16:	px = arch->sdl->size.y / 2 - tan(wall_angle) * arch->cam->d_screen;
srcs/render/render_wall.c:20:	//px = tan(wall_angle - player_angle) * arch->cam->d_screen;
srcs/render/render_wall.c:21:	//px = arch->sdl->size.y / 2 - px;
srcs/render/render_wall.c:41:	down = -player->stat.height - (player->stat.pos.z - arch->sector->h_floor);
srcs/render/render_wall.c:42:	up = down + arch->sector->h_ceil;
srcs/render/render_wall.c:56:	if (arch->px.x > arch->px.y)
srcs/render/render_wall.c:58:		tmpint = arch->px.x;
srcs/render/render_wall.c:59:		arch->px.x = arch->px.y;
srcs/render/render_wall.c:60:		arch->px.y = tmpint;
srcs/render/render_wall.c:61:		tmp = arch->depth.x;
srcs/render/render_wall.c:62:		arch->depth.x = arch->depth.y;
srcs/render/render_wall.c:63:		arch->depth.y = tmp;
srcs/render/render_wall.c:64:		tmp = arch->decal.x;
srcs/render/render_wall.c:65:		arch->decal.x = arch->decal.y;
srcs/render/render_wall.c:66:		arch->decal.y = tmp;
srcs/render/render_wall.c:67:		tmp = arch->shift_txtr.x;
srcs/render/render_wall.c:68:		arch->shift_txtr.x = arch->shift_txtr.y;
srcs/render/render_wall.c:69:		arch->shift_txtr.y = tmp;
srcs/render/render_wall.c:93:	pillar = surface_pillar(arch, player, arch->depth.x);
srcs/render/render_wall.c:94:	pillar_next = surface_pillar(arch, player, arch->depth.y);
srcs/render/render_wall.c:95:	coef_surface.x = coef_diff(pillar.x - pillar_next.x, arch->px);
srcs/render/render_wall.c:96:	coef_surface.y = coef_diff(pillar.y - pillar_next.y, arch->px);
srcs/render/render_wall.c:97:	neutre.x = (double)(arch->sdl->size.y) / arch->depth.x;
srcs/render/render_wall.c:98:	neutre.y = (double)(arch->sdl->size.y) / arch->depth.y;
srcs/render/render_wall.c:99:	coef_neutre = coef_vct(neutre, arch->px);
srcs/render/render_wall.c:101:	start = arch->px.x;
srcs/render/render_wall.c:102:	if (arch->wall->status == PORTAL)
srcs/render/render_wall.c:105:	while (arch->px.x != arch->px.y)
srcs/render/render_wall.c:108:		if (arch->wall->status == WALL)
srcs/render/render_wall.c:110:			if (z_line_buffer(arch, neutre.x, arch->px.x))
srcs/render/render_wall.c:113:		else if (arch->wall->status == PORTAL)
srcs/render/render_wall.c:121:		arch->px.x++;
srcs/render/render_wall.c:123:	if (arch->wall->status == PORTAL)
srcs/render/render_wall.c:125:		arch->px.x = start;
srcs/render/render_wall.c:127:		sector_tmp = arch->sector;
srcs/render/render_wall.c:130:		sector_render(arch, player, arch->wall->link);
srcs/render/render_wall.c:131:		arch->sector = sector_tmp;
srcs/render/textures.c:16:	px_affine.a = ((arch->sdl->size.x / 2) - arch->px.x) / arch->cam->d_screen;
srcs/render/textures.c:18:	if (arch->depth.y == arch->depth.x)
srcs/render/textures.c:20:		inter.x = arch->depth.y;
srcs/render/textures.c:22:		percent = (inter.y - arch->decal.x) / (arch->decal.y - arch->decal.x);
srcs/render/textures.c:26:		wall_affine.a = (arch->decal.y - arch->decal.x) / (arch->depth.y - arch->depth.x);
srcs/render/textures.c:27:		wall_affine.b = arch->decal.x - wall_affine.a * arch->depth.x;
srcs/render/textures.c:29:		percent = (inter.x - arch->depth.x) / (arch->depth.y - arch->depth.x);
srcs/render/textures.c:31:	percent = percent * (arch->shift_txtr.y -  arch->shift_txtr.x) + arch->shift_txtr.x;
srcs/render/textures.c:35:		return (arch->wall->txtr.w);
srcs/render/textures.c:36:	return (percent * arch->wall->txtr.w);
srcs/render/wall.c:17:	diff.x = arch->wall->pillar->p.x - p->stat.pos.x;
srcs/render/wall.c:18:	diff.y = arch->wall->pillar->p.y - p->stat.pos.y;
srcs/render/wall.c:19:	diff2.x = arch->wall->next->p.x - p->stat.pos.x;
srcs/render/wall.c:20:	diff2.y = arch->wall->next->p.y - p->stat.pos.y;
